// MIT License
//
// Copyright (c) 2025 Catmengi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.

/*
 * IMPORTANT NOTE ABOUT API CHANGES:
 * - Path to the header file: "../include/poll_network.h"
 * - poll_connection structure no longer exists
 * - poll_net_init() now only takes (port, callbacks, ctx)
 * - poll_net_start_accept() takes sockfd parameter
 * - poll_net_free() only takes poll_net_t
 * - poll_net_add_fd() returns error code
 * - New callback accept_error_cb added
 *
 * THIS CODE WAS GENERATED BY AI
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <signal.h>
#include <pthread.h>
#include <time.h>

#include "../include/poll_network.h"

#define SERVER_PORT 8080
#define CLIENT_PORT 8081
#define BUFFER_SIZE 1024
#define CLIENT_COUNT 3
#define MESSAGE_INTERVAL 2 // Seconds between client messages

// Context for callbacks
typedef struct {
    char buffer[BUFFER_SIZE];
    int client_fds[CLIENT_COUNT]; // Client connection file descriptors
    int num_clients;              // Number of active clients
    int is_client_mode;           // Flag: 1 for client context, 0 for server
    pthread_mutex_t mutex;        // Mutex for safe buffer access
} network_context_t;

// Global variables for clean shutdown
static poll_net_t g_server_net = NULL;
static poll_net_t g_client_net = NULL;
static volatile int running = 1;

// Signal handler for clean shutdown
void handle_signal(int sig) {
    printf("Signal %d received, shutting down...\n", sig);
    running = 0;
}

// Callback for accept errors
void on_accept_error(void* ctx) {
    printf("[SERVER] Error accepting connection\n");
}

// Callback when new client connects
void on_server_accept(int fd, void* ctx) {
    printf("[SERVER] New connection: fd=%d\n", fd);
}

// Callback when client disconnects
void on_server_disconnect(int fd, void* ctx) {
    printf("[SERVER] Client disconnected: fd=%d\n", fd);
}

// Callback when data is received on server
void on_server_read(int fd, void* ctx) {
    network_context_t* net_ctx = (network_context_t*)ctx;
    pthread_mutex_lock(&net_ctx->mutex);
    
    memset(net_ctx->buffer, 0, BUFFER_SIZE);
    ssize_t bytes_read = read(fd, net_ctx->buffer, BUFFER_SIZE - 1);
    
    if (bytes_read > 0) {
        net_ctx->buffer[bytes_read] = '\0';
        printf("[SERVER] Received from client fd=%d: %s", fd, net_ctx->buffer);
        
        // Echo response
        write(fd, net_ctx->buffer, bytes_read);
    }
    
    pthread_mutex_unlock(&net_ctx->mutex);
}

// Client callbacks
void on_client_accept_error(void* ctx) {
    // Should not be called for client
    printf("[CLIENT] Accept error (should not happen)\n");
}

void on_client_accept(int fd, void* ctx) {
    // Should not be called as client doesn't listen for connections
    printf("[CLIENT] Unexpected accept: fd=%d\n", fd);
}

void on_client_disconnect(int fd, void* ctx) {
    network_context_t* net_ctx = (network_context_t*)ctx;
    printf("[CLIENT] Disconnected from server: fd=%d\n", fd);
    
    pthread_mutex_lock(&net_ctx->mutex);
    // Remove disconnected fd from client list
    for (int i = 0; i < net_ctx->num_clients; i++) {
        if (net_ctx->client_fds[i] == fd) {
            // Shift remaining elements
            for (int j = i; j < net_ctx->num_clients - 1; j++) {
                net_ctx->client_fds[j] = net_ctx->client_fds[j+1];
            }
            net_ctx->num_clients--;
            break;
        }
    }
    pthread_mutex_unlock(&net_ctx->mutex);
}

void on_client_read(int fd, void* ctx) {
    network_context_t* net_ctx = (network_context_t*)ctx;
    pthread_mutex_lock(&net_ctx->mutex);
    
    memset(net_ctx->buffer, 0, BUFFER_SIZE);
    ssize_t bytes_read = read(fd, net_ctx->buffer, BUFFER_SIZE - 1);
    
    if (bytes_read > 0) {
        net_ctx->buffer[bytes_read] = '\0';
        printf("[CLIENT] Response received from server: %s", net_ctx->buffer);
    }
    
    pthread_mutex_unlock(&net_ctx->mutex);
}

// Create client connection
int create_client_connection(poll_net_t net, network_context_t* net_ctx, const char* server_ip, int server_port) {
    int client_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (client_fd < 0) {
        perror("Socket creation error");
        return -1;
    }
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_port = htons(server_port);
    
    if (inet_pton(AF_INET, server_ip, &server_addr.sin_addr) <= 0) {
        perror("Invalid address");
        close(client_fd);
        return -1;
    }
    
    if (connect(client_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Connection failed");
        close(client_fd);
        return -1;
    }
    
    printf("[CLIENT] Connected to server %s:%d, fd=%d\n", server_ip, server_port, client_fd);
    
    // Add fd to poll_net and save in context
    if (poll_net_add_fd(net, client_fd) != 0) {
        perror("Error adding socket to poll_net");
        close(client_fd);
        return -1;
    }
    
    pthread_mutex_lock(&net_ctx->mutex);
    if (net_ctx->num_clients < CLIENT_COUNT) {
        net_ctx->client_fds[net_ctx->num_clients++] = client_fd;
    }
    pthread_mutex_unlock(&net_ctx->mutex);
    
    return client_fd;
}

// Thread for periodic client message sending
void* client_send_thread(void* arg) {
    network_context_t* net_ctx = (network_context_t*)arg;
    char message[BUFFER_SIZE];
    int counter = 0;
    
    while (running) {
        pthread_mutex_lock(&net_ctx->mutex);
        
        // If there are client connections
        if (net_ctx->num_clients > 0) {
            // Form message
            counter++;
            snprintf(message, BUFFER_SIZE, "Test message #%d from client\n", counter);
            
            // Send to all clients
            for (int i = 0; i < net_ctx->num_clients; i++) {
                write(net_ctx->client_fds[i], message, strlen(message));
                printf("[CLIENT] Sent to server: %s", message);
            }
        }
        
        pthread_mutex_unlock(&net_ctx->mutex);
        
        // Wait before next send
        sleep(MESSAGE_INTERVAL);
    }
    
    return NULL;
}

int main() {
    // Set up signal handling
    signal(SIGINT, handle_signal);
    signal(SIGTERM, handle_signal);
    
    // Initialize contexts
    network_context_t server_ctx = {0};
    network_context_t client_ctx = {0};
    
    pthread_mutex_init(&server_ctx.mutex, NULL);
    pthread_mutex_init(&client_ctx.mutex, NULL);
    
    server_ctx.is_client_mode = 0;
    client_ctx.is_client_mode = 1;
    
    // ===== SERVER SETUP =====
    int server_fd = socket(AF_INET, SOCK_STREAM, 0);
    if (server_fd < 0) {
        perror("Server socket creation error");
        return 1;
    }
    
    int opt = 1;
    if (setsockopt(server_fd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt)) < 0) {
        perror("Socket options setting error");
        close(server_fd);
        return 1;
    }
    
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = htonl(INADDR_ANY);
    server_addr.sin_port = htons(SERVER_PORT);
    
    if (bind(server_fd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("Socket binding error");
        close(server_fd);
        return 1;
    }
    
    if (listen(server_fd, 5) < 0) {
        perror("Listen error");
        close(server_fd);
        return 1;
    }
    
    // Set up server callbacks
    struct poll_net_callbacks server_callbacks;
    server_callbacks.accept_error_cb = on_accept_error;  // New callback for accept errors
    server_callbacks.accept_cb = on_server_accept;
    server_callbacks.disconnect_cb = on_server_disconnect;
    server_callbacks.read_cb = on_server_read;
    
    // Initialize poll_net for server (without connection parameter)
    g_server_net = poll_net_init(SERVER_PORT, server_callbacks, &server_ctx);
    if (!g_server_net) {
        perror("Server poll_net initialization error");
        close(server_fd);
        return 1;
    }
    
    // Start accepting connections with socket passing
    poll_net_start_accept(g_server_net, server_fd);
    
    printf("[SERVER] Started on port %d\n", SERVER_PORT);
    
    // ===== CLIENT SETUP =====
    
    // Set up client callbacks
    struct poll_net_callbacks client_callbacks;
    client_callbacks.accept_error_cb = on_client_accept_error;
    client_callbacks.accept_cb = on_client_accept;
    client_callbacks.disconnect_cb = on_client_disconnect;
    client_callbacks.read_cb = on_client_read;
    
    // Initialize poll_net for client (without connection parameter)
    g_client_net = poll_net_init(0, client_callbacks, &client_ctx);
    if (!g_client_net) {
        perror("Client poll_net initialization error");
        poll_net_free(g_server_net);
        close(server_fd);
        return 1;
    }
    
    printf("[CLIENT] Initialized\n");
    
    // Create several client connections
    for (int i = 0; i < CLIENT_COUNT; i++) {
        if (create_client_connection(g_client_net, &client_ctx, "127.0.0.1", SERVER_PORT) < 0) {
            printf("Failed to create client connection #%d\n", i+1);
        }
    }
    
    // Start client message sending thread
    pthread_t sender_thread;
    pthread_create(&sender_thread, NULL, client_send_thread, &client_ctx);
    
    // Main loop
    printf("Program running. Press Ctrl+C to terminate...\n");
    while (running) {
        sleep(1);
    }
    
    // Wait for sending thread to finish
    pthread_join(sender_thread, NULL);
    
    // Free resources (simplified version without additional parameters)
    poll_net_free(g_server_net);
    poll_net_free(g_client_net);
    
    pthread_mutex_destroy(&server_ctx.mutex);
    pthread_mutex_destroy(&client_ctx.mutex);
    
    printf("Program terminated\n");
    
    return 0;
}