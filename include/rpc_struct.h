// MIT License
//
// Copyright (c) 2025 Catmengi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#pragma once

#include <stdatomic.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>

#include "hashtable.h"
#include "rpc_sizedbuf.h"

/**
 * @note Documentation Notice
 * 
 * This documentation was generated by AI and reviewed by a human.
 * If you find any inconsistencies, errors, or hallucinations in the documentation,
 * please contact the me (Catmengi)
 */

/**
 * @enum rpc_types
 * @brief Supported data types for RPC structures
 * 
 * This enumeration defines all data types that can be used in RPC struct.
 * Includes basic C types, string type, and composite types from ffiRPC.
 */
enum rpc_types{
    RPC_none, //same as void
    RPC_char = 1,
    RPC_int8 = 1,
    RPC_uint8,
    RPC_int16,
    RPC_uint16,
    RPC_int32,
    RPC_uint32,
    RPC_int64,
    RPC_uint64,
    RPC_double,

    RPC_string,
    RPC_struct,
    RPC_sizedbuf,

    RPC_unknown,
    RPC_duplicate,
};

#include "rpc_struct_internal.h"

/**
 * @typedef rpc_struct_t
 * @brief Opaque pointer to RPC structure
 *
 * This is the main container type for RPC data, used throughout the API.
 */
typedef struct _rpc_struct *rpc_struct_t;

/**
 * @brief Creates a new RPC structure
 * @return Pointer to newly created RPC structure
 */
rpc_struct_t rpc_struct_create(void);  //creates a new rpc_struct_t

/**
 * @brief Frees an RPC structure and all its contents
 * @param rpc_struct Structure to free
 */
void rpc_struct_free(rpc_struct_t rpc_struct);  //frees rpc_struct_t and ALL it's content

/**
 * @brief Removes and frees an element from structure
 * @param rpc_struct RPC structure
 * @param key Key of the element to remove
 * @return Operation status
 * @note Using the removed element causes undefined behavior
 */
int rpc_struct_remove(rpc_struct_t rpc_struct, char* key); //remove type with key "key" from rpc_struct and free it.
                                                                    //using removed element is undefined behavior because free will be done on next rpc_struct_set or rpc_struct_free or manually by rpc_struct_cleanup
/**
 * @brief Increment reference counter for pointer type ptr
 * @param ptr Pointer that isnt RPC_string or RPC_unknown and have been set to any rpc_struct_t in current proccess
 * @param increment_by increment reference counter by
 * @return 0 if item is valid, 1 item invalid or doesnt exist!
 */
int rpc_struct_refcount_increment(void* ptr, size_t increment_by);

/**
 * @brief decrement reference counter for pointer type ptr
 * @param ptr Pointer that isnt RPC_string or RPC_unknown and have been set to any rpc_struct_t in current proccess
 * @param decrement_by decrement reference counter by
 * @return 0 if item is valid, 1 item invalid or doesnt exist!
 */
int rpc_struct_refcount_decrement(void* ptr, size_t decrement_by);

/**
 * @brief Serializes RPC structure to binary format
 * @param rpc_struct Structure to serialize
 * @param buflen_output Pointer to store the resulting buffer length
 * @return Pointer to serialized data buffer
 */
char* rpc_struct_serialise(rpc_struct_t rpc_struct, size_t* buflen_output); //serialises rpc_struct into char*. Len will be outputed into buflen_output

/**
 * @brief Deserializes binary data to RPC structure
 * @param buf Buffer with serialized data
 * @return Pointer to deserialized RPC structure
 */
rpc_struct_t rpc_struct_unserialise(char* buf); //unserialise buf created with rpc_struct_serialise

/**
 * @brief Creates a full copy of an RPC structure. Copy and original still share same pointer types and AntiDoubleFree HT, but they wont cause double free if it was freed in copy or original but latter was accesed by copy or original, even if this element was added after rpc_struct_copy
 * @param original Structure to copy
 * @return Pointer to the new copy
 */
rpc_struct_t rpc_struct_copy(rpc_struct_t original); //returns a copy of "original"

/**
 * @brief Gets the number of elements in an RPC structure
 * @param rpc_struct RPC structure
 * @return Number of elements
 */
size_t rpc_struct_length(rpc_struct_t rpc_struct); //return length of rpc_struct

/**
 * @brief Gets an array of keys from the structure
 * @param rpc_struct RPC structure
 * @return Array of string pointers to keys
 */
char** rpc_struct_getkeys(rpc_struct_t rpc_struct); //return array of char* keys to elements;

/**
 * @brief Gets the type of an element by key
 * @param rpc_struct RPC structure
 * @param key Element key
 * @return Element type from rpc_types enumeration
 */
enum rpc_types rpc_struct_typeof(rpc_struct_t rpc_struct, char* key); //gets type of element

/**
 * @brief Computes a hash value for the entire structure
 * @param rpc_struct RPC structure
 * @return Hash value
 */
uint64_t rpc_struct_hash(rpc_struct_t rpc_struct); //return a hash of rpc_struct

/**
 * @brief Checks if a type is a pointer type
 * @param type Type to check
 * @return Non-zero for pointer types, 0 otherwise
 */
int rpc_is_pointer(enum rpc_types type);

/**
 * @brief Frees a container element SHOULD NOT BE CALLED MANUALLY.
 * @param element Element to free
 */
void rpc_container_free(struct rpc_container_element* element);

/**
 * @brief Cleans up pointer elements that was removed from rpc_struct.
 */
void rpc_struct_cleanup();

/**
 * @brief Internal function for setting an element in structure, may be used to overcome type system, THINK BEFORE USING!
 * @param rpc_struct RPC structure
 * @param key Element key
 * @param element Element to set
 * @return Status code
 */
int rpc_struct_set_internal(rpc_struct_t rpc_struct, char* key, struct rpc_container_element* element);

/**
 * @brief Gets access to the internal hash table of an RPC structure SHOULD NOT BE CALLED MANUALLY!
 * @param rpc_struct RPC structure
 * @return Pointer to hash table
 */
hashtable* rpc_struct_HT(rpc_struct_t rpc_struct);

/**
 * @brief Maps C types to RPC types using _Generic
 * @param Native_type The C type to map
 * @return Corresponding RPC type
 */

#define ctype_to_rpc(Native_type) (_Generic((Native_type)0,                    \
                                    char                 : RPC_char,        \
                                    int8_t               : RPC_int8,        \
                                    uint8_t              : RPC_uint8,       \
                                    int16_t              : RPC_int16,       \
                                    uint16_t             : RPC_uint16,      \
                                    int32_t              : RPC_int32,       \
                                    uint32_t             : RPC_uint32,      \
                                    int64_t              : RPC_int64,       \
                                    uint64_t             : RPC_uint64,      \
                                    float                : RPC_double,      \
                                    double               : RPC_double,      \
                                    char*                : RPC_string,      \
                                    rpc_struct_t         : RPC_struct,      \
                                    rpc_sizedbuf_t       : RPC_sizedbuf,    \
                                    default              : RPC_unknown      \
))

/**
 * @brief Sets an element in the RPC structure
 *
 * @param rpc_struct Target RPC structure
 * @param key Element key
 * @param input Value to set
 * @return 0 on success, otherwise element exists and should be removed first
 * 
 * @note String literals must be explicitly cast to char*
 * @note Strings are always copied when added to the structure
 * @note Pointers can be stored but won't be serialized
 * @note Keys are always duplicated with strdup
 *
 * @example rpc_struct_set(rpc_struct,"check_int",(uint64_t)12345678);
 */
#define rpc_struct_set(rpc_struct, key, input)({\
    int __ret = 1;\
    assert(key != NULL);\
    if(rpc_struct_typeof(rpc_struct, key) == 0){\
        struct rpc_container_element* __element = malloc(sizeof(*__element)); assert(__element);\
        c_to_rpc(__element,input);\
        __ret = rpc_struct_set_internal(rpc_struct,key,__element);\
    }\
    (int)(__ret);})

/**
 * @brief Gets an element from the RPC structure
 *
 * @param rpc_struct Source RPC structure
 * @param key Element key
 * @param output Variable to store the result (use variable name, not &variable)
 * @return 0 on success, 1 if element doesn't exist or type mismatch
 * 
 * @note Type checking is enforced with assertions
 *
 * @example 
 *   uint64_t output;
 *   assert(rpc_struct_get(rpc_struct,"check_int",output) == 0);
 *   assert(output == input);
 */
#define rpc_struct_get(rpc_struct, key, output)({assert(key != NULL);int ret = 1;struct rpc_container_element* element = hashtable_get(rpc_struct_HT(rpc_struct),key);\
if(element != NULL){assert(element->type == ctype_to_rpc(typeof(output)));if(rpc_is_pointer(element->type)){rpc_cast_value(output,(typeof(output))element->data);} else{memcpy(&output,element->data,rpctype_sizes[element->type]);} ret = 0;}(ret);})

/**
 * @brief Gets an element without type checking
 *
 * @param rpc_struct Source RPC structure
 * @param key Element key
 * @param output Variable to store the result
 * @return 0 on success, 1 if element doesn't exist
 * 
 * @note Similar to rpc_struct_get but without type checking
 * @warning May cause undefined behavior if types don't match
 */
#define rpc_struct_get_unsafe(rpc_struct, key, output)({assert(key != NULL);int ret = 1;struct rpc_container_element* element = hashtable_get(rpc_struct_HT(rpc_struct),key);\
if(element != NULL){if(rpc_is_pointer(element->type)){rpc_cast_value(output,(typeof(output))element->data);} else{memcpy(&output,element->data,rpctype_sizes[element->type]);} ret = 0;}(ret);})

