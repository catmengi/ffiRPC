// MIT License
//
// Copyright (c) 2025 Catmengi
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in all
// copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
// SOFTWARE.



#pragma once

#include <stdatomic.h>
#include <stdlib.h>
#include <stdint.h>
#include <sys/types.h>
#include <assert.h>
#include <string.h>
#include <stdio.h>

#include <jansson.h>

#include "hashtable.h"
#include "rpc_sizedbuf.h"

#define RPC_STRUCT_ID_SIZE 65


/**
 * @note Documentation Notice
 * 
 * This documentation was generated by AI and reviewed by a human.
 * If you find any inconsistencies, errors, or hallucinations in the documentation,
 * please contact the me (Catmengi)
 */

/**
 * @enum rpc_types
 * @brief Supported data types for RPC structures
 * 
 * This enumeration defines all data types that can be used in RPC struct.
 * Includes basic C types, string type, and composite types from ffiRPC.
 */
enum rpc_types{
    RPC_none, //same as void
    RPC_number,
    RPC_real,

    RPC_string,
    RPC_struct,
    RPC_sizedbuf,
    RPC_function,

    RPC_unknown,
};

#include "rpc_struct_internal.h"
#include "rpc_function.h"


/**
 * @typedef rpc_struct_t
 * @brief Opaque pointer to RPC structure
 *
 * This is the main container type for RPC data, used throughout the API.
 */
typedef struct _rpc_struct *rpc_struct_t;
typedef void (*rpc_struct_destructor)(rpc_struct_t rpc_struct);//function pointer to manualy destruct object in rpc_struct, like closing FDs or so

/**
 * @brief Creates a new RPC structure
 * @return Pointer to newly created RPC structure
 */
rpc_struct_t rpc_struct_create(void);  //creates a new rpc_struct_t
void rpc_struct_add_destructor(rpc_struct_t rpc_struct, rpc_struct_destructor manual_destructor); //adds a destructor for rpc_struct, will be called before struct free

/**
 * @brief Frees an RPC structure and all its contents
 * @param rpc_struct Structure to free
 */
void rpc_struct_free(rpc_struct_t rpc_struct);  //frees rpc_struct_t and ALL it's content

/**
 * @brief Removes and frees an element from structure
 * @param rpc_struct RPC structure
 * @param key Key of the element to remove
 * @return Operation status
 * @note Using the removed element causes undefined behavior
 */
int rpc_struct_remove(rpc_struct_t rpc_struct, char* key); //remove type with key "key" from rpc_struct and free it.

/**
 * @brief Serializes RPC structure to json
 * @param rpc_struct Structure to serialize
 * @return rpc_struct serialised into json
 * @note json is encoded in specific format because of rpc_struct's metadata like ID, and duplicates
 */
 json_t* rpc_struct_serialise(rpc_struct_t rpc_struct);

 /**
  * @brief Deserializes json to RPC structure
  * @param json rpc_struct_t serialised to json
  * @return Pointer to deserialized RPC structure
  *
  * @warning json_decref will be automaticly called on @param json
  * @note json is encoded in specific format because of rpc_struct's metadata like ID, and duplicates
  */
 rpc_struct_t rpc_struct_unserialise(json_t* json);

 /**
  * @brief Creates a full copy of an RPC structure. Copy and original still share same pointer types and AntiDoubleFree HT, but they wont cause double free if it was freed in copy or original but latter was accesed by copy or original, even if this element was added after rpc_struct_copy
  * @param original Structure to copy
  * @return Pointer to the new copy
  */
rpc_struct_t rpc_struct_copy(rpc_struct_t original); //returns a copy of "original"

/**
 * @brief Gets the number of elements in an RPC structure
 * @param rpc_struct RPC structure
 * @return Number of elements
 */
size_t rpc_struct_length(rpc_struct_t rpc_struct); //return length of rpc_struct

/**
 * @brief Gets an array of keys from the structure
 * @param rpc_struct RPC structure
 * @return Array of string pointers to keys
 */
char** rpc_struct_keys(rpc_struct_t rpc_struct); //return array of char* keys to elements;

/**
 * @brief Check is element exist
 * @param rpc_struct RPC structure
 * @param key Element key
 * @return 0 is doesnt exist, else 1
 */
int rpc_struct_exist(rpc_struct_t rpc_struct, char* key);

/**
 * @brief Gets the type of an element by key
 * @param rpc_struct RPC structure
 * @param key Element key
 * @return Element type from rpc_types enumeration
 */
enum rpc_types rpc_struct_typeof(rpc_struct_t rpc_struct, char* key); //gets type of element

/**
 * @brief Computes a hash value for the entire structure
 * @param rpc_struct RPC structure
 * @return Hash value
 */
uint64_t rpc_struct_hash(rpc_struct_t rpc_struct); //return a hash of rpc_struct

/**
 * @brief Checks if a type is a pointer type
 * @param type Type to check
 * @return Non-zero for pointer types, 0 otherwise
 */
int rpc_is_pointer(enum rpc_types type);

/**
 * @brief Internal function for setting an element in structure, may be used to overcome type system, THINK BEFORE USING!
 * @param rpc_struct RPC structure
 * @param key Element key
 * @param element Element to set
 * @return Status code
 */
int rpc_struct_set_internal(rpc_struct_t rpc_struct, char* key, struct rpc_container_element* element);

/**
 * @brief Get element with name key from rpc_struct
 * @param rpc_struct RPC structure
 * @param key Name of element to retrieve
 * @return Pointer to rpc_container_element
 */
struct rpc_container_element* rpc_struct_get_internal(rpc_struct_t rpc_struct, char* key);

/**
 * @brief Increments rpc_struct's element refcount
 * @param ptr pointer type that is inserted / was inserted to any rpc_struct_t
*/
void rpc_struct_increment_refcount(void* ptr);
/**
 * @brief Decrements rpc_struct's element refcount
 * @param ptr pointer type that is inserted / was inserted to any rpc_struct_t
 */
void rpc_struct_decrement_refcount(void* ptr);

char* rpc_struct_id_get(rpc_struct_t rpc_struct); //get rpc_struct's ID
void rpc_struct_id_set(rpc_struct_t rpc_struct, char ID[RPC_STRUCT_ID_SIZE]); //sets rpc_struct's ID to particular value

rpc_struct_t rpc_struct_whoose_copy(rpc_struct_t rpc_struct); //return pointer to copy's original. NULL if not a copy
/**
 * @brief Maps C types to RPC types using _Generic
 * @param Native_type The C type to map
 * @return Corresponding RPC type
 */

#define ctype_to_rpc(Native_type) (_Generic((Native_type)0,                    \
                                    char                 : RPC_number,        \
                                    int8_t               : RPC_number,        \
                                    uint8_t              : RPC_number,       \
                                    int16_t              : RPC_number,       \
                                    uint16_t             : RPC_number,      \
                                    int32_t              : RPC_number,       \
                                    uint32_t             : RPC_number,      \
                                    int64_t              : RPC_number,       \
                                    uint64_t             : RPC_number,      \
                                    float                : RPC_real,      \
                                    double               : RPC_real,      \
                                    char*                : RPC_string,      \
                                    rpc_struct_t         : RPC_struct,      \
                                    rpc_sizedbuf_t       : RPC_sizedbuf,    \
                                    rpc_function_t       : RPC_function,    \
                                    default              : RPC_unknown      \
))

/**
 * @brief Sets an element in the RPC structure
 *
 * @param rpc_struct Target RPC structure
 * @param key Element key
 * @param input Value to set
 * @return 0 on success, otherwise element exists and should be removed first
 * 
 * @note String literals must be explicitly cast to char*
 * @note Strings are always copied when added to the structure
 * @note Pointers can be stored but won't be serialized
 * @note Keys are always duplicated with strdup
 *
 * @example rpc_struct_set(rpc_struct,"check_int",(uint64_t)12345678);
 */
#define rpc_struct_set(__rpc_struct, __key, __input)({\
    int __ret = 1;\
    assert(__key != NULL);\
    if(rpc_struct_exist(__rpc_struct, __key) == 0){\
        struct rpc_container_element* __element = calloc(1,sizeof(*__element)); assert(__element);\
        c_to_rpc(__element,__input);\
        __ret = rpc_struct_set_internal(__rpc_struct,__key,__element);\
    }\
    (int)(__ret);})

/**
 * @brief Gets an element from the RPC structure
 *
 * @param rpc_struct Source RPC structure
 * @param key Element key
 * @param output Variable to store the result (use variable name, not &variable)
 * @return 0 on success, 1 if element doesn't exist or type mismatch
 * 
 * @note Type checking is enforced with assertions
 *
 * @example 
 *   uint64_t output;
 *   assert(rpc_struct_get(rpc_struct,"check_int",output) == 0);
 *   assert(output == input);
 */
#define rpc_struct_get(__rpc_struct, __key, __output)({assert(__key != NULL);int __ret = 1;struct rpc_container_element* __element = rpc_struct_get_internal(__rpc_struct,__key);\
if(__element != NULL){if(__element->type == ctype_to_rpc(typeof(__output))){;if(rpc_is_pointer(__element->type)){void* __copy = __element->data; memcpy(&__output,&__copy,sizeof(typeof(__copy)) > sizeof(typeof(__output)) ? sizeof(typeof(__output)) : sizeof(typeof(__copy)));} else{memcpy(&__output,__element->data,__element->length > sizeof(typeof(__output)) ? sizeof(typeof(__output)) : __element->length);} __ret = 0;}}(__ret);})

/**
 * @brief Gets an element without type checking
 *
 * @param rpc_struct Source RPC structure
 * @param key Element key
 * @param output Variable to store the result
 * @return 0 on success, 1 if element doesn't exist
 * 
 * @note Similar to rpc_struct_get but without type checking
 * @warning May cause undefined behavior if types don't match
 */
#define rpc_struct_get_unsafe(__rpc_struct, __key, __output)({assert(__key != NULL);int __ret = 1;struct rpc_container_element* __element = rpc_struct_get_internal(__rpc_struct,__key);\
if(__element != NULL){if(rpc_is_pointer(__element->type)){void* __copy = __element->data; memcpy(&__output,&__copy,sizeof(typeof(__copy)) > sizeof(typeof(__output)) ? sizeof(typeof(__output)) : sizeof(typeof(__copy)));} else{memcpy(&__output,__element->data,__element->length > sizeof(typeof(__output)) ? sizeof(typeof(__output)) : __element->length);} __ret = 0;}(__ret);})

